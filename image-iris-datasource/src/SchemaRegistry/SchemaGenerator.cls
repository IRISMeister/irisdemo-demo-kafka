Class SchemaRegistry.SchemaGenerator
{

/// Takes a multidimensional array generated by SchemaRegistry.API.GetSchemaVersion() 
/// and uses it to create IRIS classes that match that schema.
ClassMethod CreateOrReplaceClassTree(pBasePackage As %String, ByRef pSchema) As %Status
{
    Set tSC = $$$OK
    Try
    {
        Set subject=pSchema("subject")
        Set version=pSchema("version")
        Set signature=pSchema("signature")
        Set id=pSchema("id")

        TStart

        Set schema = {}.%FromJSON(pSchema("schema"))
        Set tSchemaPackage=$Translate(pBasePackage, ".","")_"."_$Translate(schema.namespace,"_-",".")

        Set tBaseClassName=pBasePackage_".AllObjects"
        Set tSC = ..CreateBaseClassIfItDoesNotExist(tBaseClassName)
        Quit:$$$ISERR(tSC)

        Set tSC = ..CreateOrReplaceClassBasedOnSchema(1, tBaseClassName, tSchemaPackage, schema, signature, subject, version, id, .createdClassName)
        Quit:$$$ISERR(tSC)

        If createdClassName'=""
        {
            Set tSC = $System.OBJ.Compile(createdClassName, "cdk")
        }
    }
    Catch (oException)
    {
        Set tSC = oException.AsStatus()
    }

    If $$$ISERR(tSC)
    {
        TRollback
    }
    Else
    {
        TCommit
    }

    Quit tSC
}

ClassMethod CreateBaseClassIfItDoesNotExist(pBaseClassName) As %Status
{
    Set tSC = $$$OK
    Try
    {
        Set oClassDef = ##class(%Dictionary.ClassDefinition).%OpenId(pBaseClassName)
        If oClassDef=""
        {
            Set oClassDef = ##class(%Dictionary.ClassDefinition).%New()
            Set oClassDef.Name=pBaseClassName
            Set oClassDef.Super="%Persistent,SchemaNormalization.OriginalData"
            Set oClassDef.Inheritance="left"
            Set oClassDef.ProcedureBlock=1

            //Index ProcessingStatusIndex On %ProcessingStatus;
            Set oIndex = ##class(%Dictionary.IndexDefinition).%New()
            Set oIndex.Name="ProcessingStatusIndex"
            Set oIndex.Properties="%ProcessingStatus"
            Do oClassDef.Indices.Insert(oIndex)

            Set tSC = oClassDef.%Save()
            Quit:$$$ISERR(tSC)

            Set tSC = $System.OBJ.Compile(pBaseClassName, "cuk")
        }   
    }
    Catch (oException)
    {
        Set tSC = oException.AsStatus()
    }

    Quit tSC
}

ClassMethod CreateOrReplaceClassBasedOnSchema(pIsRootClass As %Boolean = 1, pBaseClassName As %String, pSchemaPackage As %String, schema, signature, subject = "", version, id = "", Output pCreatedClassName As %String) As %Status
{
    #define H(%prop) $Get(pSchema(%prop))
    //#define F(%prop) $Get(pSchema("schema","fields",iField,%prop))

    Set tSC = $$$OK
    Try
    {
        Set tClassName=$Translate(schema.name,"_-.")        
        Set pCreatedClassName=pSchemaPackage_"."_tClassName

        If pIsRootClass
        {
            Set classDef = ##class(%Dictionary.ClassDefinition).%OpenId(pCreatedClassName)

            If $IsObject(classDef) && (..GetClassParameter(classDef, "SCHEMASIGNATURE")=signature)
            {
                // This schema has not changed since the last time we imported it, so we are not touching the class
                Set pCreatedClassName=""
                Quit
            }
        }

        // If we are here, it is because it is a new schema or it has changed
        // So we need to recreate the class and its subclasses

        Do ##class(%Dictionary.ClassDefinition).%DeleteId(pCreatedClassName)

        Write !,"Creating class ",pCreatedClassName,"..."
        Set classDef = ##class(%Dictionary.ClassDefinition).%New(pCreatedClassName)
        Set classDef.Inheritance="left"
        Set classDef.ProcedureBlock=1

        If pIsRootClass
        {
            Do ..AddClassParamter(classDef, "SCHEMAIMPORTDATE", $ZDateTime($Horolog,3))
            Do ..AddClassParamter(classDef, "SCHEMASIGNATURE", signature)
            Do ..AddClassParamter(classDef, "SCHEMAID", id)
            Do ..AddClassParamter(classDef, "SCHEMASUBJECT", subject)
            Do ..AddClassParamter(classDef, "SCHEMAVERSION", version)

            // We want that all events under this configuration share the same extent
            Set classDef.Super=pBaseClassName_",SchemaNormalization.OriginalData"
        }
        Else
        {
            Set classDef.Super="%SerialObject,REST.JSONRequest"
        }

        Set fieldIterator = schema.fields.%GetIterator()
        While fieldIterator.%GetNext(.key, .field)
        {
            Set bRequired = 1
            Set tIRISType=""

            If $IsObject(field.type)
            {
                If field.type.%ClassName()="%DynamicArray"
                {
                    If (field.type.%Get(0)="null") 
                    {
                        Set bRequired = 0
                        Set field.type=field.type.%Get(1)
                    }
                    ElseIf (field.type.%Get(1)="null")
                    {
                        Set bRequired = 0
                        Set field.type=field.type.%Get(0)
                    }
                }
                Else
                {                                
                    Set tSC = ..CreateOrReplaceClassBasedOnSchema(0, pBaseClassName, pSchemaPackage, field.type, signature, subject, version, id, .tIRISType)
                }
            }

            If tIRISType=""
            {
                If field.logicalType="timestamp-millis"
                {
                    Set tIRISType="%TimeStamp"
                }
                Else
                {
                    Set tIRISType=$Case(field.type, "double":"%Double",
                                                "long":"%BigInt",
                                                "int":"%Integer",
                                                "boolean":"%Boolean",
                                                "float":"%Float",
                                                :"%String")
                }
            }

            Do ..AddProperty(classDef, field.name, tIRISType, field.type, field.logicalType, bRequired, field.default)
            
        }

        Set tSC = classDef.%Save()
        Quit:$$$ISERR(tSC)

    }
    Catch (oException)
    {
        Set tSC = oException.AsStatus()
    }

    Quit tSC
}

ClassMethod AddClassParamter(pClassDef As %Dictionary.ClassDefinition, pParamName As %String, pParamValue As %String)
{
    Set oParam = ##class(%Dictionary.ParameterDefinition).%New()
    Set oParam.Default=pParamValue
    Set oParam.Name=pParamName
    Do pClassDef.Parameters.Insert(oParam)
}

ClassMethod GetClassParameter(pClassDef As %Dictionary.ClassDefinition, pParamName As %String) As %String
{
    For i=1:1:pClassDef.Parameters.Count()
    {
        Set oParam = pClassDef.Parameters.GetAt(i)
        If oParam.Name=pParamName
        {
            Return oParam.Default
        }
    }
    Return ""
}

ClassMethod AddProperty(pClassDef As %Dictionary.ClassDefinition, pPropertyName As %String, pIRISType As %String, pType As %String, pLogicalType As %String, pRequired As %Boolean, pDefaultValue As %String)
{
    Set oProp = ##class(%Dictionary.PropertyDefinition).%New()
    Set oProp.Name=pPropertyName
    Set oProp.Type=pIRISType
    Set oProp.Required=pRequired
    If pDefaultValue'="" Set oProp.InitialExpression = """"_pDefaultValue_""""
    Do pClassDef.Properties.Insert(oProp)
}

}
